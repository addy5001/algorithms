package questions;

import java.util.Arrays;

/**
 * Coloring each component: For each node, if it isn't yet colored, use a depth-first search to traverse its component,
 * coloring that component with a new color.
 *
 * Size of each color: Count the number of occurrences of each color.
 *
 * Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.
 *
 * Choose answer: For each node with a unique color, find the size of that color.
 * The largest size is selected, with ties broken by lowest node number.
 *
 * If there is no node with a unique color, the answer is min(initial).
 */

public class MinimizeMalwareSpread {
    int[] connectedGroups;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        connectedGroups = new int[n];
        Arrays.fill(connectedGroups, -1);

        int group = 0;
        for(int i=0; i<graph.length; i++) {
            if(connectedGroups[i] == -1) {
                _findConnectedGroups(graph, group++, i);
            }
        }

        int[] size = new int[group];
        for(int nodeGroup : connectedGroups) {
            size[nodeGroup]++;
        }

        int[] uniqueGroups = new int[group];
        for(int node : initial) {
            uniqueGroups[connectedGroups[node]]++;
        }

        int nodeToRemove = Integer.MAX_VALUE;
        for(int node : initial) {
            int nodeGroup = connectedGroups[node];
            if(uniqueGroups[nodeGroup] == 1) {
                if(nodeToRemove == Integer.MAX_VALUE)
                    nodeToRemove = node;
                else if(size[nodeGroup] > size[connectedGroups[nodeToRemove]])
                    nodeToRemove = node;
                else if(size[nodeGroup] == size[connectedGroups[nodeToRemove]] && node < nodeToRemove)
                    nodeToRemove = node;
            }
        }

        if(nodeToRemove == Integer.MAX_VALUE) {
            for(int node : initial) {
                nodeToRemove = Math.min(node, nodeToRemove);
            }
        }

        return nodeToRemove;
    }

    private void _findConnectedGroups(int[][] graph, int group, int node) {
        if(connectedGroups[node] != -1)
            return;

        connectedGroups[node] = group;
        for(int neighbor=0; neighbor<graph.length; neighbor++) {
            if(node == neighbor)
                continue;

            if(connectedGroups[neighbor] == -1 && graph[node][neighbor] == 1) {
                _findConnectedGroups(graph, group, neighbor);
            }
        }
    }
}
